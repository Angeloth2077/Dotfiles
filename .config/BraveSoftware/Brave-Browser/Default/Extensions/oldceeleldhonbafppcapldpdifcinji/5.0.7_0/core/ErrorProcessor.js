class ErrorProcessor{static merge(r,e=!1){let{errors:t,pickyErrors:s,premiumErrors:o,premiumPickyErrors:a}=this.filterAndMigrateErrors(r.existing.errors,r.existing.pickyErrors,r.existing.premiumErrors,r.existing.premiumPickyErrors,r.existingCheckedText,r.newCheckedText);return this.mergeParagraphLevelErrors(t,s,o,a,r.new.paragraphLevel.errors,r.new.paragraphLevel.pickyErrors,r.new.paragraphLevel.premiumErrors,r.new.paragraphLevel.premiumPickyErrors),this.mergeTextLevelErrors(t,s,o,a,r.new.textLevel.errors,r.new.textLevel.pickyErrors,r.new.textLevel.premiumErrors,r.new.textLevel.premiumPickyErrors),this.sortErrors(t,s,o,a),this.setIdsOnErrors(t,s,o,a),t=this.migrateErrorsToOriginalText(t,r.newCheckedText.usedParts),s=this.migrateErrorsToOriginalText(s,r.newCheckedText.usedParts),o=this.migrateErrorsToOriginalText(o,r.newCheckedText.usedParts),a=this.migrateErrorsToOriginalText(a,r.newCheckedText.usedParts),e&&(s.forEach((r=>{r.rule.id="HIDDEN_RULE",r.fixes=[]})),o=[...o,...a,...s],a=[],s=[],this.sortErrorsByOffset(o)),{errors:t,pickyErrors:s,premiumErrors:o,premiumPickyErrors:a}}static migrateErrorsToValuableText(r,e){const t=[];for(const s of r){const r=binarySearch(e,(r=>compareNumberAndSegment(s.start,r.originalStart,r.originalEnd,!0))),o=binarySearch(e,(r=>compareNumberAndSegment(s.end,r.originalStart,r.originalEnd)));if(!r||!o)continue;const a=deepClone(s);a.start-=r.posDiff,a.end-=o.posDiff,a.length=a.end-a.start,t.push(a)}return t}static migrateErrorsBetweenTexts(r,e,t,s){let o,a=!1;"string"==typeof e&&"string"==typeof t?(o=getParagraphsDiff(e,t),a="boolean"==typeof s&&s):(o=e,a="boolean"==typeof t&&t);const i=[];for(const e of r){const r=binarySearch(o,(r=>{const t=r.oldOffset;if(null===r.oldText)return e.start>=t?1:-1;const s=r.oldOffset+r.oldText.length+1;return compareNumberAndSegment(e.start,t,s,!0)})),t=deepClone(e);if(r){if(r.textDiff){if(a)continue;{const e=r.oldOffset+r.textDiff.from,s=e+r.textDiff.oldFragment.length;if(isIntersect(e,s,t.start,t.end,!0))continue;if(t.start>=s){const e=r.textDiff.newFragment.length-r.textDiff.oldFragment.length;t.start+=e,t.end+=e}}}t.start+=r.newOffset-r.oldOffset,t.end=t.start+t.length}i.push(t)}return i}static migrateErrorsToOriginalText(r,e){const t=[];for(const s of r){const r=binarySearch(e,(r=>compareNumberAndSegment(s.start,r.start,r.end,!0))),o=binarySearch(e,(r=>compareNumberAndSegment(s.end,r.start,r.end)));if(!r||!o)continue;const a=deepClone(s);a.start+=r.posDiff,a.end+=o.posDiff,a.length=a.end-a.start,t.push(a)}return t}static filterAndMigrateErrors(r,e,t,s,o,a){r=r.filter((r=>r.isParagraphLevelCheck)),e=e.filter((r=>r.isParagraphLevelCheck)),t=t.filter((r=>r.isParagraphLevelCheck)),s=s.filter((r=>r.isParagraphLevelCheck)),r=this.migrateErrorsToValuableText(r,o.usedParts),e=this.migrateErrorsToValuableText(e,o.usedParts),t=this.migrateErrorsToValuableText(t,o.usedParts),s=this.migrateErrorsToValuableText(s,o.usedParts);const i=getParagraphsDiff(o.text,a.text);return{errors:r=this.migrateErrorsBetweenTexts(r,i,!0),pickyErrors:e=this.migrateErrorsBetweenTexts(e,i,!0),premiumErrors:t=this.migrateErrorsBetweenTexts(t,i,!0),premiumPickyErrors:s=this.migrateErrorsBetweenTexts(s,i,!0)}}static mergeParagraphLevelErrors(r,e,t,s,o,a,i,n){r.push(...o),e.push(...a),t.push(...i),s.push(...n)}static mergeTextLevelErrors(r,e,t,s,o,a,i,n){for(const e of o)r.some((r=>r.start===e.start&&r.end===e.end))||r.push(e);for(const r of a)e.some((e=>e.start===r.start&&e.end===r.end))||e.push(r);for(const r of i)t.some((e=>e.start===r.start&&e.end===r.end))||t.push(r);for(const r of n)s.some((e=>e.start===r.start&&e.end===r.end))||s.push(r)}static sortErrors(r,e,t,s){this.sortErrorsByOffset(r),this.sortErrorsByOffset(e),this.sortErrorsByOffset(t),this.sortErrorsByOffset(s)}static sortErrorsByOffset(r){r.sort(((r,e)=>r.start===e.start?r.isParagraphLevelCheck?1:-1:r.start>e.start?1:-1))}static migrateErrorsBetweenSameOriginalTexts(r,e,t){const s=[];for(const o of r){let r=o.start,a=o.end,i=binarySearch(e.usedParts,(e=>compareNumberAndSegment(r,e.originalStart,e.originalEnd,!0))),n=binarySearch(e.usedParts,(r=>compareNumberAndSegment(a,r.originalStart,r.originalEnd)));if(!i||!n)continue;if(r-=i.posDiff,a-=n.posDiff,i=binarySearch(t.usedParts,(e=>compareNumberAndSegment(r,e.start,e.end,!0))),n=binarySearch(t.usedParts,(r=>compareNumberAndSegment(a,r.start,r.end))),!i||!n)continue;r+=i.posDiff,a+=n.posDiff;const f=deepClone(o);f.start=r,f.end=a,f.length=a-r,s.push(f)}return s}static setIdsOnErrors(r,e,t,s){const o={};r.forEach((r=>{const e=`${r.rule.id}:${r.originalPhrase}`;o[e]=o[e]?o[e]+1:1,r.id=`${e}:${o[e]}`})),e.forEach((r=>{const e=`${r.rule.id}:${r.originalPhrase}`;o[e]=o[e]?o[e]+1:1,r.id=`${e}:${o[e]}`})),t.forEach((r=>{const e=`${r.rule.id}:${r.originalPhrase}`;o[e]=o[e]?o[e]+1:1,r.id=`${e}:${o[e]}`})),s.forEach((r=>{const e=`${r.rule.id}:${r.originalPhrase}`;o[e]=o[e]?o[e]+1:1,r.id=`${e}:${o[e]}`}))}}